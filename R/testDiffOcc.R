#' Differential occurrence test on Barcodes across sample groups
#'
#' @param barbieQ A `barbieQ` object created by the [createBarbieQ] function.
#' @param regularization A string specifying the regularization method when
#'  testing 'diffOcc'. Options: 'firth' and 'none'. Defaults to 'firth'.
#' @param mycontrasts A numeric vector generated by [limma::makeContrasts]
#' @param contrastLevels A charactor vector specifying the levels of conditions
#'  in the factor specified by `sampleGroups`. Defaults to the original
#'  levels of conditions in the specified factor.
#' @param designMatrix A numeric matrix standardizing `targets`, generated by
#'  the [stats::model.matrix] function. Defaults to be generated by
#'  `designFormula`.
#'
#' @importFrom logistf logistf
#' @importFrom magrittr %>%
#' @importFrom stats as.formula
#' @importFrom stats model.matrix
#' @importFrom stats glm
#' @importFrom stats p.adjust
#'
#' @noRd
#'
#' @return A `data.frame` of statistical test results for each Barcode
#'
#' @examples \donttest{
#' Treat <- factor(rep(c("ctrl", "drug"), each = 6))
#' Time <- rep(rep(seq_len(2), each = 3), 2)
#' nbarcodes <- 50
#' nsamples <- 12
#' count <- abs(matrix(rnorm(nbarcodes * nsamples), nbarcodes, nsamples))
#' rownames(count) <- paste0("Barcode", seq_len(nbarcodes))
#' barbieQ <- createBarbieQ(count, data.frame(Treat = Treat, Time = Time))
#' barbieQ <- testDiffOcc(barbieQ,
#'   regularization = "firth",
#'   mycontrasts = mycontrasts, contrastLevels = contrastLevels,
#'   designMatrix = designMatrix
#' )
#' barbieQ:::testDiffOcc(
#'   barbieQ = barbieQ,
#'   mycontrasts = c(-1, 1, 0),
#'   contrastLevels = c("ctrl", "drug"),
#'   designMatrix = model.matrix(~ 0 + Treat + Time)
#' )
#' }
testDiffOcc <- function(
    barbieQ, regularization = "firth", mycontrasts = NULL, contrastLevels = NULL,
    designMatrix = NULL) {
  ## check 'regularization'
  regularization <- match.arg(regularization, c("firth", "none"))
  if (is.null(rownames(barbieQ$occurrence))) {
    rownames(barbieQ$occurrence) <- rownames(barbieQ$assay)
  }
  if (is.null(rownames(barbieQ$occurrence))) {
    rownames(barbieQ$occurrence) <- paste0("barcode", seq(nrow(barbieQ$occurrence)))
  }
  ## extract binary data
  occurrence <- barbieQ$occurrence + 1 - 1
  ## regenerate designMatrix based on the mycontrasts specified identify variables
  ## based on contrast rules
  mycontrasts <- data.frame(mycontrasts)
  rownames(mycontrasts) <- colnames(designMatrix)
  interceptVar <- rownames(mycontrasts)[mycontrasts == -1]
  primaryVar <- rownames(mycontrasts)[mycontrasts == 1]
  additionalVar <- rownames(mycontrasts)[mycontrasts == 0]
  ## recreate the formula add intercept if existing
  formulaStr <- paste(primaryVar)
  ## add additional variable if existing
  formulaStr <- paste(c(formulaStr, additionalVar), collapse = " + ")

  ## recreate design without the intercept (interceptVar serves as reference)
  formulaStr <- paste0("~ ", formulaStr)
  formula <- stats::as.formula(formulaStr)
  design <- stats::model.matrix(formula, data = data.frame(designMatrix))

  ## make designMatrix full rank by deleting columns of nested effectors, ie.
  ## linearly related vectors compute QR decomposition of the designMatrix
  q <- qr(design)
  keep <- rep(TRUE, ncol(design))
  ## select the indices in the pivot vector after the rank of the matrix the
  ## columns of matrix that are linearly dependent (those that do not contribute to
  ## the rank)
  keep[q$pivot[-seq(q$rank)]] <- FALSE
  design <- design[, keep, drop = FALSE]

  ## case when 'none' regularization, fit classic model
  if (regularization == "none") {
    results <- lapply(seq_len(nrow(occurrence)), function(i) {
      stats::glm(occurrence[i, ] ~ design - 1, family = "binomial") %>%
        summary()
    })
    ## extract stats
    tag <- paste0("design", primaryVar)
    p.value <- lapply(results, function(x) {
      x$coefficients[tag, "Pr(>|z|)"]
    }) %>%
      unlist()
    logOR <- lapply(results, function(x) {
      x$coefficients[tag, "Estimate"]
    }) %>%
      unlist()
    z <- lapply(results, function(x) {
      x$coefficients[tag, "z value"]
    }) %>%
      unlist()
    ## extract stats result sheet
    statMat <- data.frame(p.value = p.value, logOR = logOR, z = z)
    rownames(statMat) <- rownames(occurrence)
  } else if (regularization == "firth") {
    ## case when 'firth' regularization, fit penalized logistic model
    results <- lapply(seq_len(nrow(occurrence)), function(i) {
      invisible(logistf::logistf(occurrence[i, ] ~ design - 1))
    })
    tag <- paste0("design", primaryVar)
    ## extract stats
    p.value <- lapply(results, function(x) {
      x$prob[tag]
    }) %>%
      unlist()
    logOR <- lapply(results, function(x) {
      x$coefficients[tag]
    }) %>%
      unlist()
    lowerCI <- lapply(results, function(x) {
      x$ci.lower[tag]
    }) %>%
      unlist()
    upperCI <- lapply(results, function(x) {
      x$ci.upper[tag]
    }) %>%
      unlist()
    ## extract stats result sheet
    statMat <- data.frame(p.value = p.value, logOR = logOR, lowerCI = lowerCI, upperCI = upperCI)
    rownames(statMat) <- rownames(occurrence)
    message("model fitted by Penalized ML. confidence intervals and p-values by Profile Likelihood.")
  }
  ## compute adjusted p.values
  adj.p.value <- stats::p.adjust(statMat$p.value, method = "BH")
  ## decide direction
  direction <- ifelse(adj.p.value >= 0.05, "n.s.", ifelse(statMat$logOR > 0, contrastLevels[2],
    contrastLevels[1]
  ))

  BarcodeBiasOcc <- data.frame(direction = direction, adj.p.value = adj.p.value, statMat)

  message("adj.p.value is adjusted by 'Benjamini-Hochberg false discovery rate'.")

  return(BarcodeBiasOcc)
}
