#' Test significant change in Barcode proportion or occurrence
#'  between sample groups
#'
#' `testBarcodeBias()` tests differential proportion (diffProp) or
#'  occurrence (diffOcc) for each Barcode between sample groups,
#'  with the option account for multiple factors using regression models.
#'  The results can be visualized by [plotBarcodeBiasScatterPlot] and
#'  [plotBarcodeBiasHeatmap].
#'
#' @param barbieQ A `barbieQ` object created by the [createBarbieQ] function.
#' @param method A string specifying what is to be tested.
#'  Options: 'diffProp' and 'diffOcc'. Defaults to 'diffProp'.
#' @param targets A `matrix` or `data.frame` of sample conditions,
#'  where each factor is represented in a separate column. Defaults to NULL,
#'  in which case sample conditions are inherited from `barbieQ$metadata`.
#' @param sampleGroups A string representing the name of a factor from the
#'  sample conditions passed by `barbieQ` or `targets`, or a vector of
#'  sample conditions, indicating the primary factor to be tested.
#'  Defaults to the first factor in the sample conditions.
#' @param contrastLevels A charactor vector specifying the levels of conditions
#'  in the factor specified by `sampleGroups`. Defaults to the original
#'  levels of conditions in the specified factor.
#' @param designFormula A formula to compute the `designMatrix`, generated by
#'  the [stats::as.formula] function. Defaults to include all factors
#'  in the sample conditions.
#' @param designMatrix A numeric matrix standardizing `targets`, generated by
#'  the [stats::model.matrix] function. Defaults to be generated by
#'  `designFormula`.
#' @param block A vector (array) indicating sample duplicates. Defaults to
#'  no duplicates among the samples.
#' @param transformation A string specifying the transformation method when
#'  testing 'diffProp'. Options include: 'asin-sqrt', 'logit', and 'none'.
#'  Defaults to 'asin-sqrt'.
#' @param regularization A string specifying the regularization method when
#'  testing 'diffOcc'. Options: 'firth' and 'none'. Defaults to 'firth'.
#'
#' @return A `barbieQ` object updated with a `testBarcodes` component, adding
#'  a `list` named by the test name, containing:
#'   * `results`: a `data.frame` of statistical test results,
#'    including p-values, etc.
#'   * `methods`: a `list` indicating the specific statistical test method used.
#'   * `targets`: a numeric `matrix` of the standardized design matrix
#'    used in the test.
#'
#' @export
#'
#' @importFrom limma makeContrasts
#' @importFrom magrittr %>%
#' @importFrom dplyr setdiff
#' @importFrom stats as.formula
#' @importFrom stats model.matrix
#'
#' @examples
#' Block <- c(1, 1, 2, 3, 3, 4, 1, 1, 2, 3, 3, 4)
#' Treat <- factor(rep(seq_len(2), each = 6))
#' Time <- rep(rep(seq_len(2), each = 3), 2)
#' nbarcodes <- 50
#' nsamples <- 12
#' count <- abs(matrix(rnorm(nbarcodes * nsamples), nbarcodes, nsamples))
#' rownames(count) <- paste0('Barcode', seq_len(nbarcodes))
#' barbieQ <- createBarbieQ(count, data.frame(Treat = Treat, Time = Time))
#' testBarcodeBias(barbieQ, sampleGroups = 'Treat')
testBarcodeBias <- function(barbieQ, method = "diffProp", targets = NULL, sampleGroups = NULL,
    contrastLevels = NULL, designFormula = NULL, designMatrix = NULL, block = NULL, transformation = "asin-sqrt",
    regularization = "firth") {
    ## check barbieQ dimensions
    checkBarbieQDimensions(barbieQ)
    ## check method: confirm method is chosen from 'diffProp' and 'diffOcc'
    method <- match.arg(method, c("diffProp", "diffOcc"))
    ## extract targets and primary effector based on arguments
    targetsInfo <- extractTargetsAndPrimaryFactor(barbieQ = barbieQ, targets = targets, sampleGroups = sampleGroups)
    mytargets <- targetsInfo$mytargets
    pointer <- targetsInfo$pointer
    ## extract the groupTitle to be compared: sampleGroups
    groupTitle <- colnames(mytargets)[pointer]
    ## confirm all effectors (columns) in 'mytargets' are factor() or numeric() convert
    ## columns that are neither factor nor numeric into factor
    nonFac <- vapply(mytargets, function(x) !(is.factor(x) | is.numeric(x)), logical(1))
    for (col in seq(nonFac)[nonFac]) {
        mytargets[, col] <- factor(mytargets[, col])
    }
    ## remove factor columns with only one level - will be problematic in model.matrix
    oneLevelFactors <- vapply(mytargets, function(x) {
        is.factor(x) && length(unique(x)) == 1
    }, logical(1))
    if (any(oneLevelFactors)) {
        mytargets <- mytargets[, !oneLevelFactors]
        message("removing effectors with only one level from targets: ", paste0(colnames(mytargets)[oneLevelFactors],
            collapse = ", "))
    }

    ## import 'design' using tidy evaluation if designFormula not specified, taking all
    ## effectors from 'mytargets' into account prioritize the column of sampleGroups to
    ## be compared
    if (is.null(designFormula)) {
        otherCols <- dplyr::setdiff(colnames(mytargets), groupTitle)
        ## create the formula string based on the presence of other columns
        formulaStr <- if (length(otherCols) > 0) {
            paste("~0 +", groupTitle, "+", paste(otherCols, collapse = " + "))
        } else {
            paste("~0 +", groupTitle)
        }
        ## convert to formula
        designFormula <- stats::as.formula(formulaStr)
    }

    ## check designFormula format
    if (!inherits(designFormula, "formula")) {
        stop("The 'designFormula' argument must be a valid formula.")
    } else {
        ## check if all variables in designFormula are present in 'mytargets'
        missingTerms <- dplyr::setdiff(all.vars(designFormula), colnames(mytargets))
        if (length(missingTerms) > 0) {
            stop("The following variables in the 'designFormula' are missing from 'targets' or 'barbieQ$metadata':",
                paste(missingTerms, collapse = ", "))
        }
    }

    ## if designMatrix not specified, generate it by designFormula
    if (is.null(designMatrix)) {
        designMatrix <- stats::model.matrix(designFormula, data = mytargets)
    } else {
        ## check designMatrix format and dimension
        if (is.matrix(designMatrix) || is.data.frame(designMatrix)) {
            if (nrow(designMatrix) != nrow(mytargets)) {
                stop("row dimension of 'designMatrix' doean't match row dimension of 'targets' or 'barbieQ$metadata'.")
            } else {
                ## using specified `designMatrix` and deleting the default
                ## `designFormula` to avoid confusion
                designFormula <- "NA"
            }
        } else {
            stop("'designMatrix' should always be a matrix. use fucntion model.matrix() to generate a 'designMatrix'.")
        }
    }

    ## make designMatrix full rank by deleting columns of nested effectors, ie.
    ## linearly related vectors compute QR decomposition of the designMatrix
    q <- qr(designMatrix)
    keep <- rep(TRUE, ncol(designMatrix))
    ## select the indices in the pivot vector after the rank of the matrix the columns
    ## of matrix that are linearly dependent (those that do not contribute to the rank)
    keep[q$pivot[-seq(q$rank)]] <- FALSE
    designMatrix <- designMatrix[, keep, drop = FALSE]
    ## message the users if any linearly related vectors are deleted
    if (any(!keep)) {
        message(sum(!keep), " nested effector(s) in the designMatrix were deleted because designMatrix must be full rank.")
    }

    ## check block groups if it's specified
    if (!(is.null(block))) {
        if (length(block) != ncol(barbieQ$assay)) {
            stop("the length of 'block' doesn't match the row dimention (sample size) of specified 'targets' or 'barbieQ$metadata'.")
        }
    }

    ## 'pointer' indicates which column relates to 'sampleGroups': either a imported
    ## 'sampleGroups' column or a column name specified by 'sampleGroups' like 'Treat'
    ## case when sampleGroups column is factor
    if (is.factor(mytargets[, pointer])) {
        ## make group contrast, extract levels if not specified
        if (is.null(contrastLevels)) {
            contrastLevels <- levels(mytargets[, pointer])
        } else if (is.vector(contrastLevels)) {
            missingLevels <- dplyr::setdiff(contrastLevels, levels(mytargets[, pointer]))
            if (length(missingLevels) > 0) {
                stop("'contrastLevels' constains levels: ", missingLevels, " missing from the 'sampleGroups' column in 'targets' or 'barbieQ$metadata'.")
            }
        } else {
            stop("'contrastLevels' argument should be a vector indicating levels in the 'sampleGroups' column in 'targets' or 'barbieQ$metadata'.")
        }

        ## now 'contrastLevels' should be a vector indicating levels in the
        ## 'sampleGroups' column 'contrastLevels' has one, two, or several levels.
        if (length(contrastLevels) == 2L) {
            ## create contrast for the first two levels of 'sampleGroups'
            contrastFormula <- paste0(groupTitle, contrastLevels[2], " - ", groupTitle, contrastLevels[1])
            ## generate contrast for designMatrix
            mycontrasts <- limma::makeContrasts(contrasts = contrastFormula, levels = colnames(designMatrix))
        } else {
            stop("'contrastLevels' has ", length(contrastLevels), " level(s), it should contain two levels for the 'sampleGroups' factor in 'targets' or 'barbieQ$metadata'.")
        }
    } else if (is.numeric(mytargets[, pointer])) {
        ## case when sampleGroups column is numeric generate contrast for designMatrix
        mycontrasts <- limma::makeContrasts(contrasts = groupTitle, levels = colnames(designMatrix))
        contrastLevels <- c("decrease", "increase")
    }

    ## store test information
    testMethods <- list(aim = "", formula = designFormula, design = designMatrix, method = "",
        transformation = "", regularization = "", adjusted.p.value = "Benjamini-Hochberg false discovery rate",
        contrastVector = groupTitle, contrastLevels = contrastLevels)

    ## all test results will be saved in barbieQ$testBarcodes
    if (is.null(barbieQ$testBarcodes)) {
        barbieQ$testBarcodes <- list()
    }

    ## dispatch test functions based on the specified method default setting is
    ## 'diffProp'
    if (method == "diffProp") {
        BarcodeBiasProp <- testDiffProp(barbieQ = barbieQ, transformation = transformation,
            mycontrasts = mycontrasts, contrastLevels = contrastLevels, designMatrix = designMatrix,
            block = block)
        ## clarify test methods information
        testMethods$aim <- "testing differential proportion"
        testMethods$method <- "linear regression"
        testMethods$transformation <- transformation
        ## store test results and methods
        elementName <- paste0("diffProp_", groupTitle)
        if (!is.null(barbieQ$testBarcodes[[elementName]])) {
            message("overwriting exsiting test results")
        }
        barbieQ$testBarcodes[[elementName]] <- list(results = BarcodeBiasProp, methods = testMethods,
            targets = mytargets)
    } else if (method == "diffOcc") {
        ## logistic regression, default regularization is 'firth'
        BarcodeBiasOcc <- testDiffOcc(barbieQ, regularization = regularization, mycontrasts = mycontrasts,
            contrastLevels = contrastLevels, designMatrix = designMatrix)
        ## clarify test methods information
        testMethods$aim <- "testing differential occurrence"
        testMethods$method <- "logistic regression"
        testMethods$regularization <- regularization
        ## store test results and methods
        elementName <- paste0("diffOcc_", groupTitle)
        if (!is.null(barbieQ$testBarcodes[[elementName]])) {
            message("overwriting exsiting test results")
        }
        barbieQ$testBarcodes[[elementName]] <- list(results = BarcodeBiasOcc, methods = testMethods,
            targets = mytargets)
    } else {
        stop("please choose test method from 'diffProp' or 'diffOcc'.")
    }

    ## assign colors for the test results
    if (is.null(barbieQ$factorColors[[elementName]])) {
        barbieQ$factorColors[[elementName]] <- setNames(c("#33AAFF", "#FF5959", "#FFC000"),
            c(contrastLevels[1], contrastLevels[2], "n.s."))
    }

    message("test methods saved in barbieQ$testBarcodes$methods.")

    return(barbieQ)
}
