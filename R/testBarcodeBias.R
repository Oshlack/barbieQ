#' Test significant change in Barcode proportion or occurrence
#'  between sample groups
#'
#' `testBarcodeBias()` tests differential proportion (diffProp) or
#'  occurrence (diffOcc) for each Barcode between sample groups,
#'  with the option account for multiple factors using regression models.
#'  The results can be visualized by [plotBarcodeBiasScatterPlot] and
#'  [plotBarcodeBiasHeatmap].
#'
#' @param Barbie A `Barbie` object created by the [createBarbie] function.
#' @param method A string specifying what is to be tested.
#'  Options: "diffProp" and "diffOcc". Defaults to "diffProp".
#' @param targets A `matrix` or `data.frame` of sample conditions,
#'  where each factor is represented in a separate column. Defaults to NULL,
#'  in which case sample conditions are inherited from `Barbie$metadata`.
#' @param sampleGroups A string representing the name of a factor from the
#'  sample conditions passed by `Barbie` or `targets`, or a vector of
#'  sample conditions, indicating the primary factor to be tested.
#'  Defaults to the first factor in the sample conditions.
#' @param contrastLevels A charactor vector specifying the levels of conditions
#'  in the factor specified by `sampleGroups`. Defaults to the original
#'  levels of conditions in the specified factor.
#' @param designFormula A formula to compute the `designMatrix`, generated by
#'  the [stats::as.formula] function. Defaults to include all factors
#'  in the sample conditions.
#' @param designMatrix A numeric matrix standardizing `targets`, generated by
#'  the [stats::model.matrix] function. Defaults to be generated by
#'  `designFormula`.
#' @param block A vector (array) indicating sample duplicates. Defaults to
#'  no duplicates among the samples.
#' @param transformation A string specifying the transformation method when
#'  testing "diffProp". Options include: "asin-sqrt", "logit", and "none".
#'  Defaults to "asin-sqrt".
#' @param regularization A string specifying the regularization method when
#'  testing "diffOcc". Options: "firth" and "none". Defaults to "firth".
#'
#' @return A `Barbie` object updated with a `testBarcodes` component, adding
#'  a `list` named by the test name, containing:
#'   * `results`: a `data.frame` of statistical test results,
#'    including p-values, etc.
#'   * `methods`: a `list` indicating the specific statistical test method used.
#'   * `targets`: a numeric `matrix` of the standardized design matrix
#'    used in the test.
#'
#' @export
#'
#' @importFrom limma makeContrasts
#' @importFrom magrittr %>%
#' @importFrom dplyr setdiff
#' @importFrom stats as.formula
#' @importFrom stats model.matrix
#'
#' @examples
#' Block <- c(1, 1, 2, 3, 3, 4, 1, 1, 2, 3, 3, 4)
#' Treat <- factor(rep(seq_len(2), each = 6))
#' Time <- rep(rep(seq_len(2), each = 3), 2)
#' nbarcodes <- 50
#' nsamples <- 12
#' count <- abs(matrix(rnorm(nbarcodes * nsamples), nbarcodes, nsamples))
#' rownames(count) <- paste0("Barcode", seq_len(nbarcodes))
#' Barbie <- createBarbie(count, data.frame(Treat = Treat, Time = Time))
#' testBarcodeBias(Barbie, sampleGroups = "Treat")
testBarcodeBias <- function(
    Barbie, method = "diffProp",
    targets = NULL, sampleGroups = NULL, contrastLevels = NULL,
    designFormula = NULL, designMatrix = NULL,
    block = NULL, transformation = "asin-sqrt", regularization = "firth") {
  ## check Barbie dimensions
  checkBarbieDimensions(Barbie)
  ## check method: confirm method is chosen from "diffProp" and "diffOcc"
  method <- match.arg(method, c("diffProp", "diffOcc"))
  ## extract targets and primary effector based on arguments
  targetsInfo <- extractTargetsAndPrimaryFactor(
    Barbie = Barbie, targets = targets, sampleGroups = sampleGroups
  )
  mytargets <- targetsInfo$mytargets
  pointer <- targetsInfo$pointer
  ## extract the groupTitle to be compared: sampleGroups
  groupTitle <- colnames(mytargets)[pointer]
  ## confirm all effectors (columns) in 'mytargets' are factor() or numeric()
  ## convert columns that are neither factor nor numeric into factor
  nonFac <- vapply(
    mytargets, function(x) !(is.factor(x) | is.numeric(x)), logical(1)
  )
  for (col in seq(nonFac)[nonFac]) {
    mytargets[, col] <- factor(mytargets[, col])
  }
  ## remove factor columns with only one level - will be problematic in model.matrix
  oneLevelFactors <- vapply(
    mytargets, function(x) is.factor(x) && length(unique(x)) == 1, logical(1)
  )
  if (any(oneLevelFactors)) {
    mytargets <- mytargets[, !oneLevelFactors]
    message(
      "removing effectors with only one level from targets: ",
      paste0(colnames(mytargets)[oneLevelFactors], collapse = ", ")
    )
  }

  ## import 'design' using tidy evaluation
  ## if designFormula not specified, taking all effectors from 'mytargets' into account
  ## prioritize the column of sampleGroups to be compared
  if (is.null(designFormula)) {
    designFormula <- paste(
      "~0 + ", paste(
        groupTitle,
        paste0("+ ", dplyr::setdiff(
          colnames(mytargets), groupTitle
        ), collapse = " ")
      )
    ) %>%
      stats::as.formula()
  }
  ## check designFormula format
  if (!inherits(designFormula, "formula")) {
    stop("The 'designFormula' argument must be a valid formula.")
  } else {
    ## check if all variables in designFormula are present in 'mytargets'
    missingTerms <- dplyr::setdiff(all.vars(designFormula), colnames(mytargets))
    if (length(missingTerms) > 0) {
      stop(
        "The following variables in the 'designFormula' are missing from 'targets' or 'Barbie$metadata':",
        paste(missingTerms, collapse = ", ")
      )
    }
  }

  ## if designMatrix not specified, generate it by designFormula
  if (is.null(designMatrix)) {
    designMatrix <- stats::model.matrix(designFormula, data = mytargets)
  } else {
    ## check designMatrix format and dimension
    if (is.matrix(designMatrix) || is.data.frame(designMatrix)) {
      if (nrow(designMatrix) != nrow(mytargets)) {
        stop("row dimension of 'designMatrix' doean't match row dimension of 'targets' or 'Barbie$metadata'.")
      }
    } else {
      stop("'designMatrix' should always be a matrix. use fucntion model.matrix() to generate a 'designMatrix'.")
    }
  }

  ## make designMatrix full rank by deleting columns of nested effectors, ie. linearly related vectors
  ## compute QR decomposition of the designMatrix
  q <- qr(designMatrix)
  keep <- rep(TRUE, ncol(designMatrix))
  ## select the indices in the pivot vector after the rank of the matrix
  ## the columns of matrix that are linearly dependent (those that do not contribute to the rank)
  keep[q$pivot[-seq(q$rank)]] <- FALSE
  designMatrix <- designMatrix[, keep, drop = FALSE]
  ## message the users if any linearly related vectors are deleted
  if (any(!keep)) {
    message(sum(!keep), " nested effector(s) in the designMatrix were deleted because designMatrix must be full rank.")
  }

  ## check block groups if it's specified
  if (!(is.null(block))) {
    if (length(block) != ncol(Barbie$assay)) {
      stop("the length of 'block' doesn't match the row dimention (sample size) of specified 'targets' or 'Barbie$metadata'.")
    }
  }

  ## 'pointer' indicates which column relates to 'sampleGroups': either a imported 'sampleGroups' column or a column name specified by 'sampleGroups' like 'Treat'
  ## case when sampleGroups column is factor
  if (is.factor(mytargets[, pointer])) {
    ## make group contrast, extract levels if not specified
    if (is.null(contrastLevels)) {
      contrastLevels <- levels(mytargets[, pointer])
    } else if (is.vector(contrastLevels)) {
      missingLevels <- dplyr::setdiff(
        contrastLevels, levels(mytargets[, pointer])
      )
      if (length(missingLevels) > 0) {
        stop("'contrastLevels' constains levels: ", missingLevels, " missing from the 'sampleGroups' column in 'targets' or 'Barbie$metadata'.")
      }
    } else {
      stop("'contrastLevels' argument should be a vector indicating levels in the 'sampleGroups' column in 'targets' or 'Barbie$metadata'.")
    }

    ## now 'contrastLevels' should be a vector indicating levels in the 'sampleGroups' column
    ## 'contrastLevels' has one, two, or several levels.
    if (length(contrastLevels) == 2L) {
      ## create contrast for the first two levels of 'sampleGroups'
      contrastFormula <- paste0(
        groupTitle, contrastLevels[2], " - ", groupTitle, contrastLevels[1]
      )
      ## generate contrast for designMatrix
      mycontrasts <- limma::makeContrasts(
        contrasts = contrastFormula,
        levels = colnames(designMatrix)
      )
    } else {
      stop("'contrastLevels' has ", length(contrastLevels), " level(s), it should contain two levels for the 'sampleGroups' factor in 'targets' or 'Barbie$metadata'.")
    }
  } else if (is.numeric(mytargets[, pointer])) {
    ## case when sampleGroups column is numeric
    ## generate contrast for designMatrix
    mycontrasts <- limma::makeContrasts(
      contrasts = groupTitle,
      levels = colnames(designMatrix)
    )
    contrastLevels <- c("decrease", "increase")
  }

  ## store test information
  testMethods <- list(
    aim = "",
    formula = designFormula,
    method = "",
    transformation = "",
    regularization = "",
    adjusted.p.value = "Benjamini-Hochberg false discovery rate",
    contrastVector = groupTitle,
    contrastLevels = contrastLevels
  )

  ## all test results will be saved in Barbie$testBarcodes
  if (is.null(Barbie$testBarcodes)) Barbie$testBarcodes <- list()

  ## dispatch test functions based on the specified method
  ## default setting is "diffProp"
  if (method == "diffProp") {
    BarcodeBiasProp <- testDiffProp(
      Barbie = Barbie, transformation = transformation,
      mycontrasts = mycontrasts, contrastLevels = contrastLevels,
      designMatrix = designMatrix, block = block
    )
    ## clarify test methods information
    testMethods$aim <- "testing differential proportion"
    testMethods$method <- "linear regression"
    testMethods$transformation <- transformation
    ## store test results and methods
    elementName <- paste0("diffProp_", groupTitle)
    if (!is.null(Barbie$testBarcodes[[elementName]])) {
      message("overwriting exsiting test results")
    }
    Barbie$testBarcodes[[elementName]] <- list(
      results = BarcodeBiasProp,
      methods = testMethods,
      targets = mytargets
    )
  } else if (method == "diffOcc") {
    ## logistic regression, default regularization is "firth"
    BarcodeBiasOcc <- testDiffOcc(
      Barbie,
      regularization = regularization,
      mycontrasts = mycontrasts, contrastLevels = contrastLevels,
      designMatrix = designMatrix
    )
    ## clarify test methods information
    testMethods$aim <- "testing differential occurrence"
    testMethods$method <- "logistic regression"
    testMethods$regularization <- regularization
    ## store test results and methods
    elementName <- paste0("diffOcc_", groupTitle)
    if (!is.null(Barbie$testBarcodes[[elementName]])) {
      message("overwriting exsiting test results")
    }
    Barbie$testBarcodes[[elementName]] <- list(
      results = BarcodeBiasOcc,
      methods = testMethods,
      targets = mytargets
    )
  } else {
    stop("please choose test method from 'diffProp' or 'diffOcc'.")
  }

  ## assign colors for the test results
  if (is.null(Barbie$factorColors[[elementName]])) {
    Barbie$factorColors[[elementName]] <- setNames(
      c("#33AAFF", "#FF5959", "#FFC000"),
      c(contrastLevels[1], contrastLevels[2], "n.s.")
    )
  }

  message("test methods saved in Barbie$testBarcodes$methods.")

  return(Barbie)
}
